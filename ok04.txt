 

Занятие 4 OK04

Занятие OK04 основано на OK03, обучая тому, как использовать таймер для мигания светодиода «OK» или «ACT» через определенные промежутки времени. Предполагается, что у вас есть код для Занятие 3: операционная система OK03 в качестве основы.
1 Новое устройство

Таймер - единственный способ, которым Pi может отсчитывать время. В большинстве компьютеров есть часы с батарейным питанием, чтобы отсчитывать время в выключенном состоянии.

До сих пор мы рассматривали только одно оборудование на Raspberry Pi, а именно контроллер GPIO. Я просто сказал тебе, что делать, и это случилось. Теперь мы рассмотрим таймер, и я расскажу вам, как он работает.

Как и у контроллера GPIO, у таймера есть адрес. В этом случае таймер находится по адресу 2000300016. Читая руководство пользователя, находим следующую таблицу:
Таблица 1.1 Контроллер GPIO  Адреса Регистров 	Размер / Байты 	Имя 	Описание 	Чтение или запись
20003000 	4 	Control / Status 	Регистр, используемый для контроля и очистки совпадений компаратора канала таймера. 	RW
20003004 	8 	Counter 	Счетчик, который увеличивается на 1 МГц. 	R
2000300C 	4 	Сравнить 0 0-й регистр сравнения. 	RW
20003010 	4 	Сравнить 1 1-й регистр сравнения. 	RW
20003014 	4 	Compare 2/Сравнить 2 2-й регистр сравнения. 	RW
20003018 	4 	Compare 3 	3rd Comparison register. 	RW
Схема работы системного таймера

Tего таблица говорит нам о многом, но описания различных полей в руководстве говорят нам больше всего. В руководстве объясняется, что таймер просто увеличивает значение счетчика на 1 каждые 1 микросекунду. Каждый раз, когда он это делает, он сравнивает младшие 32 бита (4 байта) значения счетчика с 4 регистрами сравнения, и, если он соответствует любому из них, обновляет Control / Status, чтобы отразить, какие из них совпали.

Для получения дополнительной информации о битах, байтах, битовых полях и размерах данных разверните поле ниже.

Объяснение битов
	

Бит - это имя одной двоичной цифры. Как вы помните, одна двоичная цифра - это либо 1, либо 0.

Байт - это имя, которое мы даем коллекции из 8 бит. Поскольку каждый бит может быть одним из двух значений, существует 2^8 = 256 различных возможных значений для байта. Обычно мы интерпретируем байт как двоичное число от 0 до 255 включительно.
Схема контроллера выбора функции GPIO, регистр 0.	

Битовое поле - это еще один способ интерпретации двоичного (кода?). Вместо того, чтобы интерпретировать его как число, двоичный файл можно интерпретировать как множество разных вещей. Битовое поле обрабатывает двоичный файл как последовательность переключателей, которые либо включены (1), либо выключены (0). Если у нас есть значение для каждого из этих маленьких переключателей, мы можем использовать их для управления вещами. На самом деле мы уже встречали битовые поля с контроллером GPIO, с включением или выключением пина. Бит, который был равен 1, был контактом GPIO для фактического включения или выключения. Иногда нам нужно больше опций, чем просто включить или выключить, поэтому мы группируем несколько переключателей вместе, например, с настройками функций контроллера GPIO (на рисунке), в которых каждая группа из 3 бит управляет одной функцией вывода GPIO.


Наша цель - реализовать функцию, которую мы можем вызвать с определенным количеством времени в качестве входных данных, которое будет ждать это количество времени, а затем вернет (вернет, что? Значение? выяснить и дописать). Подумайте на мгновение, как мы могли бы это сделать, учитывая то, что у нас есть.

Я вижу два варианта:

     1) Считайте значение из счетчика, а затем продолжайте переходить обратно к тому же коду, пока счетчик не покажет время ожидания больше, чем было.
    2) Считайте значение со счетчика, добавьте время ожидания, сохраните его в одном из регистров сравнения, а затем продолжайте переходить обратно в тот же код, пока не обновится регистр управления / состояния.

Подобные проблемы называются проблемами параллелизма, и исправить их практически невозможно.

Обе эти стратегии будут работать нормально, но в этом уроке мы реализуем только первую. Причина в том, что регистры сравнения с большей вероятностью будут ошибаться, поскольку за время, необходимое для добавления времени ожидания и сохранения его в регистре сравнения, счетчик мог увеличиться, и поэтому он не будет соответствовать. Это может привести к очень долгим непреднамеренным задержкам, если запрошено ожидание в 1 микросекунду (или, что еще хуже, ожидание в 0 микросекунд).
2 Реализация

Большие операционные системы обычно используют функцию ожидания как возможность для выполнения фоновых задач.

Я по большей части оставлю вам задачу создания идеального метода ожидания. Я предлагаю вам поместить весь код, связанный с таймером, в файл с именем 'systemTimer.s' (надеюсь, по очевидным причинам). Сложность этого метода заключается в том, что счетчик представляет собой 8-байтовое значение, но каждый регистр содержит только 4 байта. Таким образом, значение счетчика будет занимать два регистра.

Следующие блоки кода являются примерами.

ldrd r0,r1,[r2,#4] 

ldrd regLow, regHigh, [src, # val] загружает 8 байтов из адреса, заданного числом в src plus val, в regLow и regHigh .

Инструкция, которая может оказаться полезной, - это инструкция ldrd выше. Он загружает 8 байтов памяти в 2 регистра. В этом случае 8 байтов памяти, начиная с адреса в r2, будут скопированы в r0 и r1. Что немного сложнее в этом расположении, так это то, что r1 на самом деле содержит 4 старших байта. Другими словами, если бы счетчик имел значение 999,999,999,99910 = 11101000110101001010010100001111111111112, r1 содержало бы 111010002, а r0 - 110101001010010100001111111111112.

Наиболее разумный способ реализовать это - вычислить разницу между текущим значением счетчика и значением с момента запуска метода, а затем сравнить это с запрошенным временем ожидания. Удобно, если вы не хотите поддерживать время ожидания, равное 8 байтам, значение в r1 в приведенном выше примере можно отбросить, и нужно использовать только младшие 4 байта счетчика.

Когда ожидаете, вы всегда должны быть уверены, что используете более высокие сравнения, а не сравнения на равенство, как если бы вы пытались дождаться, когда промежуток между временем запуска метода и временем его окончания будет точно запрошенным количеством, вы можете пропустить значение и подождать навсегда.

Если вы не можете понять, как закодировать функцию ожидания, разверните поле ниже, чтобы получить руководство.

Реализация функции ожидания
	

Заимствуя идею из контроллера GPIO, первая функция, которую мы должны написать, должна получить адрес этого системного таймера. Пример этого показан ниже:

.globl GetSystemTimerBase
GetSystemTimerBase:
ldr r0,=0x20003000
mov pc,lr 

Другой полезной функцией будет функция, возвращающая текущее значение счетчика в регистрах r0 и r1:

.globl GetTimeStamp
GetTimeStamp:
push {lr}
bl GetSystemTimerBase
ldrd r0,r1,[r0,#4]
pop {pc} 

Эта функция просто использует функцию GetSystemTimerBase и загружает значение счетчика с помощью ldrd, как мы только что узнали.

Теперь мы действительно хотим закодировать наш метод ожидания. Прежде всего, нам нужно знать значение счетчика при запуске метода, которое теперь мы можем получить с помощью GetTimeStamp.

delay .req r2
mov delay,r0
push {lr}
bl GetTimeStamp
start .req r3
mov start,r0 

Этот код копирует ввод нашего метода, количество времени для задержки, в r2, а затем вызывает GetTimeStamp, который, как мы знаем, вернет текущее значение счетчика в r0 и r1. Затем он копирует младшие 4 байта значения счетчика в r3.

Затем нам нужно вычислить разницу между текущим значением счетчика и только что полученным показанием, а затем продолжать делать это до тех пор, пока разрыв между ними не станет по крайней мере равным размеру задержки.

loop$ (Цикл$):

bl GetTimeStamp
elapsed .req r1
sub elapsed,r0,start
cmp elapsed,delay
.unreq elapsed
bls loop$ 

Этот код будет ждать, пока не пройдет запрошенное время. Он берет показание счетчика, вычитает из него начальное значение и затем сравнивает его с запрошенной задержкой. Если истекшее время меньше запрошенной задержки, он возвращается к loop$.

.unreq delay
.unreq start
pop {pc} 

Этот код завершает функцию, возвращая.

3 Еще один мигающий Светодиод

Как только вы получите то, что вы считаете работающей функцией ожидания, измените main.s, чтобы использовать ее. Измените везде, где вы ждете, чтобы установить значение r0 на какое-то большое число (помните, что это в микросекундах), а затем протестируйте его на Raspberry Pi. Если он не работает должным образом, перейдите на нашу страницу устранения неполадок.

После того, как он заработал, поздравляем, вы освоили другое устройство, а вместе с ним и само время. В следующем и последнем уроке из серии OK, Урок 5: OK05, мы будем использовать все, что мы узнали, чтобы высветить узор (или рисунок) на светодиоде.

Обнаружили ошибку? Вы можете помочь этому учебнику на GitHub.

Creative Commons Licence
Baking Pi: Operating Systems Development by Alex Chadwick is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.

Based on contributions at https://github.com/chadderz121/bakingpi-www.

Переводчик этого курса на русский язык Калин Геннадий Геннадьевич, Краснодар.

