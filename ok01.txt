 

Занятие 1 OK01

Урок OK01 содержит объяснение того, как начать работу, и объясняет, как включитьодин из светодиодов «OK» или «ACT» на плате Raspberry Pi рядом с портами RCA и USB.. Раньше этот индикатор имел название OK, но был переименован в ACT на платах Raspberry Pi версии 2.
1 Начинаем.

Вы должны были посетить страницу загрузок и скачать инструменты GNU Toolchain. Также на странице загрузок есть файл который называется OS Template. Пожалуйста скачайте его и распакуйте его в новую папку.
2 Начало.

Расширение .s, обычно используется для всех видов ассемблерного кода, мы должны помнить, что в этом случае, это код ARMv6.

Теперь, когда вы распаковали OS Template, создайте новый файл в исходном каталоге с именем 'main.s'. Этот файл будет содержать код для этой операционной системы. Структура папок должна выглядеть так:

 build/
    (empty)
source/
    main.s
kernel.ld
LICENSE
Makefile

Откройте 'main.s' в текстовом редакторе так что мы можем писать ассемблерный код. Raspberry Pi использует вид ассемблерного кода под названием ARMv6, так что это то, что нам нужно написать.

Скопируйте эти первые команды.

 .section .init
 .globl _start
 _start:

Это и есть инструкции ассемблера. Ассемблер - это программа, которая переводит между понятным нам ассемблерным кодом и двоичным машинным кодом, который понимает процессор. В ассемблерном коде каждая строка представляет собой новую команду. Первая строка здесь сообщает Ассемблеру [1], где разместить наш код. Этот шаблон  приводит к тому, что код из раздела с именем .init помещается в начало вывода. Это важно, поскольку мы хотим убедиться, что можем управлять запуском кода, какой именно код запустится первым. Если мы этого не сделаем, сначала будет запущен код из первого по алфавиту имени файла! Команда .section просто сообщает ассемблеру, в какой раздел поместить код, от этого момента до следующего .section или конца файла.

В ассемблерном коде вы можете пропускать строки и ставить пробелы перед и после команд для облегчения чтения.

Следующие две строки предназначены для остановки предупреждающего сообщения и не так важны. [2]
3 Первая строка

Сейчас мы собираемся, кое что закодировать. В ассемблерном коде компьютер просто просматривает код, выполняя каждую инструкцию по порядку, если не сказано иное. Каждая инструкция начинается с новой строки.

Скопируйте следующую инструкцию:

ldr r0,=0x20200000 

ldr reg,=val помещает число val в регистр с именем reg.

Это наша первая команда. Он сообщает процессору сохранить номер 0x20200000 в регистр r0. Здесь мне нужно будет ответить на два вопроса: Что такое регистр и как 0x20200000 является числом?

В одном регистре может храниться любое целое число от 0 до 4294967295 включительно на Raspberry Pi, что может показаться большим объемом памяти, но это всего 32 двоичных разряда.

Регистр - это крошечный фрагмент памяти в процессоре, в котором процессор хранит числа, над которыми он сейчас работает. Их довольно много, многие из которых имеют особое значение, к которому мы вернемся позже. Важно то, что есть 13 регистров (с именами r0, r1, r2, ..., r9, r10, r11, r12), которые называются универсальными, и вы можете использовать их для любых вычислений, которые вам нужны. Поскольку это первый, я использовал в этом примере регистр r0, но я вполне мог использовать любой из других. Пока вы последовательны, это не имеет значения.

0x20200000 это действительно число. Однако оно записано в шестнадцатеричной системе счисления. Чтобы узнать больше о шестнадцатеричном формате, разверните поле ниже:

Шестнадцатеричное исчисление

Итак, наша первая команда - поместить число 2020000016 в r0. Не похоже, что от этого будет много пользы, но это. В компьютерах очень много блоков памяти и устройств. Чтобы получить к ним доступ, мы даем каждому адрес. Как и почтовый адрес или веб-адрес, это просто средство определения местоположения устройства или фрагментов памяти, которые нам нужны. Адреса в компьютерах - это просто числа, поэтому число 2020000016 оказывается адресом контроллера GPIO. Это просто проектное решение, принятое производителями, они могли использовать любой другой адрес (при условии, что он не конфликтует ни с чем другим).. Я знаю этот адрес только потому, что искал его в руководстве [3], нет никакой конкретной системы для адресов (кроме того, что все они являются большими круглыми числами в шестнадцатеричном формате).
4 Включение вывода
Схема, показывающая основные части контроллера GPIO..

Прочитав руководство, я знаю, что нам нужно будет отправить два сообщения на контроллер GPIO. Нам нужно говорить на его языке, но если мы это сделаем, он сделает то, что мы хотим, и включит светодиод OK.. К счастью, это настолько простой чип что ему нужно всего несколько цифр, чтобы понять, что делать.

 mov r1,#1
 lsl r1,#18
 str r1,[r0,#4]

mov reg,#val помещает число val в регистр с именем reg.

lsl reg, #val сдвигает двоичное представление числа в reg на val мест влево.

str reg, [dest, #val] сохраняет число в reg по адресу, заданному dest + val.

Эти команды разрешают вывод на 16-й вывод GPIO. Сначала мы получаем необходимое значение в r1, затем отправляем его в контроллер GPIO. Поскольку первые две инструкции просто пытаются получить значение в r1, мы могли бы использовать другую команду ldr, как и раньше, но позже нам будет полезно иметь возможность установить любой данный вывод GPIO, поэтому лучше вывести значение из формулы, чем написать ее прямо. Светодиод OK подключен к 16-му выводу GPIO, поэтому нам нужно отправить команду для включения 16-го вывода.

Значение в r1 необходимо для включения вывода светодиода. В первой строке число 110 помещается в r1. Команда mov работает быстрее, чем команда ldr, потому что она не требует взаимодействия с памятью, тогда как ldr загружает значение, которое мы хотим поместить в регистр из памяти. Однако mov можно использовать только для загрузки определенных значений [4]. В ассемблерном коде ARM почти каждая инструкция начинается с кода состоящего из трех букв. Это называется мнемоникой, и предполагается, что она намекает на то, что делает операция. Сам термин мнемоника указывает на античную науку запоминания - Мнемонику. Ведь за мнемониками ассемблера скрывается непосредственно машинный код. mov - это сокращение от move (шаг) , а ldr - от load register (загрузить регистр). mov перемещает второй аргумент #1 в первый r1. В общем, для обозначения чисел необходимо использовать #, но мы уже видели контрпример к этому.

Вторая инструкция - это lsl или логический сдвиг влево (logical shift left).  Это означает сдвиг двоичного представления для первого аргумента, оставленного вторым аргументом. В этом случае это сдвинет двоичное представление 110 (что составляет 12) влево на 18 позиций (что делает его 10000000000000000002 = 26214410).

Если вы не знакомы с двоичным кодом, разверните поле ниже:

Двоичный код

Еще раз повторюсь, я знаю только то, что мы нуждаемся в этом значении которое мы прочитали из руководства[3]. В руководстве говорится, что в контроллере GPIO есть набор из 24 байт, которые определяют настройки вывода GPIO. Первые 4 относятся к первым 10 контактам GPIO, вторые 4 относятся к следующим 10 и так далее. Имеется 54 контакта GPIO, поэтому нам нужно 6 наборов по 4 байта, что всего 24 байта. В каждом 4-байтовом разделе каждые 3 бита относятся к конкретному выводу GPIO. Поскольку нам нужен 16-й вывод GPIO, нам нужен второй набор из 4 байтов, потому что мы имеем дело с выводами 10-19, и нам нужен 6-й набор из 3 бит, откуда берется число 18 (6 × 3) в коде выше.

Наконец, команда str 'store register' (сохранить регистр) сохраняет значение первого аргумента, r1, по адресу, вычисленному впоследствии из выражения. Выражение может быть регистром, в данном случае r0, который, как мы знаем, является адресом контроллера GPIO, и другим значением, которое нужно добавить к нему, в данном случае #4. Это означает, что мы добавляем 4 к адресу контроллера GPIO и записываем значение в r1 в этом месте. Это место расположения второго набора из 4 байтов, о котором я упоминал ранее, и поэтому мы отправляем наше первое сообщение контроллеру GPIO, сообщая ему, чтобы он подготовил 16-й вывод GPIO для вывода.
5 Признак жизни

Теперь, когда светодиод готов к включению, нам нужно включить его. Это означает отправку сообщения контроллеру GPIO для выключения контакта 16. Да выключи это. Производители чипа решили, что имеет смысл [5] включать светодиод, когда вывод GPIO выключен. Кажется, что инженеры по аппаратному обеспечению часто принимают такие решения, по-видимому, просто для того, чтобы держать разработчиков ОС в тонусе. Считайте себя предупрежденным.


mov r1,#1
lsl r1,#16
str r1,[r0,#40]

Надеюсь вы должны узнать все вышеуказанные команды, если не их значения. Первый, как и прежде, помещает 1 в r1. Второй сдвигает двоичное представление этой единицы влево на 16 позиций. Поскольку мы хотим выключить контакт 16, нам необходимо иметь 1 в 16-м бите этого следующего сообщения (другие значения будут работать для других контактов). Наконец, мы записываем его по адресу, который 4010 добавляет к адресу контроллера GPIO, который является адресом для записи, чтобы выключить контакт (28 включит контакт).
6 Долго и счастливоr

Может возникнуть соблазн закончить сейчас, но, к сожалению, процессор не знает, что мы закончили. В действительности процессор никогда не остановится. Пока у него есть питание, он продолжает работать. Таким образом, нам нужно дать ему задачу что то всегде делать, иначе Raspberry Pi выйдет из строя (в этом примере это не большая проблема, свет уже горит).


loop$:
b loop$

имя: помечает имя следующей строки.

Метка b вызывает выполнение следующей строки как метку.

Первая строка здесь не команда, а меткаl. Она называет следующую строку loop$. Это означает, что теперь мы можем ссылаться на строку по имени. Это называется меткой. Метки отбрасываются, когда код превращается в двоичный, но они полезны в наших интересах для ссылки на строки по имени, а не по номеру (адресу). По соглашению мы используем $ для меток, которые важны только для кода в этом блоке кода, чтобы другие знали, что они не важны для всей программы. Команда b ( (branch) (ветка)) приводит к тому, что следующая строка будет выполняться на указанной метке, а не на следующей за ней. Поэтому, следующей выполняемой строкой будет эта строка b, что приведет к ее повторному выполнению и так далее до бесконечности. Таким образом, процессор застревает в красивом бесконечном цикле, пока не будет безопасно выключен.

Новая строка в конце блока является преднамеренной. Набор инструментов GNU ожидает, что все файлы ассемблерного кода будут заканчиваться пустой строкой, так что он будет уверен, что вы действительно закончили, и файл не был отрезан. Если вы ее не поставите, то получите раздражающее предупреждение при запуске ассемблера.
7 Время Pi

Итак, мы написали код, чтобы перенести его на pi. Откройте терминал на своем компьютере и измените текущий рабочий каталог на родительский каталог исходного каталога. Наберите в терминале make и нажмите клавишу enter. Если возникнут какие-либо ошибки, то пожалуйста обратитесь к разделу устранения неполадок. Это полезный навык. Если все пройдет без проблем, то у вас создадутся три файла. kernel.img это скомпилированный образ вашей операционной системы. kernel.list листинг кода сборки, который вы написали, как он в действительности был сгенерирован. Это полезно для проверки правильности создания объектов в будущем. The kernel.map файл содержит карту того, где оказались все метки, что может быть полезно для поиска значений.

Чтобы установить операционную систему, прежде всего установите на sd карту операционную систему для Raspberry PI. Если вы просмотрите файлы на SD-карте, вы должны увидеть файл с названием kernel.img. Переименуйте этот файл во что-нибудь другое, например linux_kernel.img. Затем скопируйте созданный файл kernel.img на sd карту. Вы только что заменили существующую операционную систему своей собственной. Чтобы переключиться обратно, просто удалите файл kernel.img, а другой переименуйте обратно в kernel.img. Я считаю, что всегда полезно сохранить резервную копию оригинальной операционной системы Raspberry Pi на случай, если она вам снова понадобится.

Вставьте sd карту в Raspberry Pi и включите его. Светодиод OK должен загореться. Если светодиод не загорелся, то перейдите на страницу устранения неполадок. Если светодиод загорелся, тогда поздравляю, вы только что написали свою первую операционную систему. См. Урок 2: OK02, чтобы узнать, как включить и выключить светодиодную вспышку..

    [1]^ Хорошо, я вру, это сообщает компоновщику, который является еще одной программой, используемой для связывания нескольких собранных файлов вместе. Это не имеет значения.
    [2]^ Очевидно, они важны для вас. Поскольку набор инструментов GNU в основном используется для создания программ, предполагается наличие точки входа с меткой _start. Когда мы создаем операционную систему, _start всегда означает то, что идет первым, что мы устанавливаем с помощью команды .section .init. Однако, если мы не скажем, где находится точка входа, цепочка инструментов расстроится. Таким образом, первая строка говорит, что мы собираемся определить символ с именем _start для всеобщего обозрения (глобально), а вторая строка говорит, что нужно сделать символ _start адресом следующей строки. Скоро мы займемся адресами.
    [3]^^ Этот учебник разработан, чтобы избавить вас от боли при его чтении, но, если вам нужно, его можно найти здесь SoC-Peripherals.pdf. Для дополнительной путаницы в руководстве используется другая система адресации. Адрес, указанный как 0x7E200000, будет в нашей ОС 0x20200000.
    [4]^ Только значения которые имеют двоичное представление которое имеет только 1s в первых 8 битах представления. Другими словами, 8 1s или 0s, за которыми следуют только 0s.
    [5]^ Инженер по аппаратному обеспечению был достаточно любезен, чтобы объяснить мне это следующим образом:

    Причина в том, что современные микросхемы сделаны по технологии под названием CMOS, что расшифровывается как Complementary Metal Oxide Semiconductor. Дополнительная часть означает, что каждый сигнал подключен к двум транзисторам, один из которых изготовлен из материала, называемого полупроводником N-типа, который используется для вывода его на низкое напряжение, а другой из материала P-типа для вывода его на высокое напряжение. В любой момент включается только один транзистор из пары, иначе мы получим короткое замыкание. P-тип не такой проводящий, как N-тип, что означает, что транзистор P-типа должен быть примерно в 3 раза больше, чтобы обеспечивать такой же ток. Вот почему светодиоды часто подключаются для включения, потянув их на низкий уровень, потому что N-тип сильнее при низком понижении, чем P-тип при высоком.

    Есть еще одна причина. Еще в 1970-х микросхемы были сделаны полностью из материала N-типа (NMOS), а P-тип был заменен резистором. Это означает, что когда сигнал понижается, чип потребляет энергию (и нагревается), даже если он ничего не делает. Когда телефон лежит в кармане, он нагревается и разряжается аккумулятор. Поэтому сигналы были спроектрированы так, чтобы быть "active low", чтобы они были высокими, когда неактивны, и поэтому не потребляли никакой энергии.. 
Несмотря на то, что мы больше не используем NMOS, все же часто быстрее установить низкий уровень сигнала с помощью N-типа, чем поднять его с помощью P-типа. Часто сигнал, являющийся «активным минимумом», отмечается полосой над названием или записывается как SIGNAL_n или / SIGNAL. Но это все равно может сбивать с толку даже инженеров по аппаратному обеспечению!

Обнаружили ошибку? Вы можете помочь этому учебнику на GitHub.

Creative Commons Licence
Baking Pi: Operating Systems Development by Alex Chadwick is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.

Based on contributions at https://github.com/chadderz121/bakingpi-www.

Переводчик этого курса на русский язык Калин Геннадий Геннадьевич, Краснодар.
