 

Занятие 5 OK05

Урок OK05 основан на OK04, используя его для прошивки шаблона кода Морзе SOS (...---...). Предполагается, что у вас есть код для Урок 4: операционная система OK04 в качестве основы.
1 Данные

Пока что все, что нам нужно было сделать с нашей операционной системой, - это предоставить инструкции, которым нужно следовать. Однако иногда инструкции - это только половина дела. Нашим операционным системам могут потребоваться данные.

Некоторые ранние операционные системы допускали только определенные типы данных в определенных файлах, но, как правило, это было слишком ограничительно. Однако современный способ значительно усложняет программы.

В целом данные - это просто важные значения. Вероятно, вы привыкли думать о данных как о конкретном типе, например текстовый файл содержит текст, файл изображения содержит изображение и т. д. На самом деле это всего лишь идея. Все данные на компьютере - это просто двоичные числа, имеет значение то, как мы их интерпретируем. В этом примере мы собираемся сохранить последовательность мигания светодиода, как данные.

В конце main.s скопируйте следующий код:

.section .data
.align 2
pattern:
.int 0b11111111101010100010001000101010 

.align num гарантирует, что адрес следующей строки кратен 2num .

.int val выводит число val.

Чтобы различать данные и код, мы помещаем все данные в .data. Я включил это в схему компоновки памяти операционной системы здесь. Я просто решил поместить данные после конца кода. Причина, по которой наши данные и инструкции хранятся отдельно, заключается в том, что если мы в конечном итоге реализуем некоторую безопасность в нашей операционной системе, нам нужно знать, какие части кода могут быть выполнены, а какие - нет.

Я использовал здесь две новые команды. .align и .int. .align обеспечивает выравнивание следующих данных с указанной степенью двойки. In this case I've used .align 2 which means that this data will definitely be placed at an address which is a multiple of 22 = 4. Это действительно важно, потому что инструкция ldr, которую мы использовали для чтения памяти, работает только с адресами, кратными 4.

Команда .int копирует константу после нее непосредственно в вывод. Это означает, что 111111111010101000100010001010102 будет помещено в вывод, и поэтому шаблон метки фактически помечает этот фрагмент данных как шаблон.

Одна из проблем с данными - найти эффективное и полезное представление. Этот метод хранения последовательности как включенной и выключенной единиц времени легко запустить, но будет трудно отредактировать, так как концепция Морса - или потеряна. is lost.

Как я уже говорил, данные могут означать все, что вы хотите. В этом случае я закодировал SOS-последовательность азбукой Морзе, которая ... --- ... для тех, кто не знаком. Я использовал 0 для обозначения единицы времени при выключенном светодиодном индикаторе и 1 для обозначения единицы времени при включенном светодиоде. Таким образом, мы можем написать некоторый код, который просто отображает последовательность данных, подобную этой, а затем все, что нам нужно сделать, чтобы он отображал другую последовательность, - это изменить данные. Это очень простой пример того, что операционные системы должны делать постоянно; интерпретировать и отображать данные.

Скопируйте следующие строки перед меткой цикла loop $ в main.s.

ptrn .req r4
ldr ptrn,=pattern
ldr ptrn,[ptrn]
seq .req r5
mov seq,#0 

Этот код загружает шаблон в r4 и загружает 0 в r5. r5 будет нашей позицией последовательности, поэтому мы можем отслеживать, какую часть паттерна мы отобразили.

Следующий код помещает ненулевое значение в r1 тогда и только тогда, когда в текущей части шаблона стоит 1.

mov r1,#1
lsl r1,seq
and r1,ptrn 

Этот код полезен для ваших вызовов SetGpio, который должен иметь ненулевое значение для выключения светодиода и нулевое значение для включения светодиода.

Теперь измените весь свой код в main.s так, чтобы каждый цикл кода устанавливал светодиод на основе текущего порядкового номера, ждал 250000 микросекунд (или любую другую подходящую задержку), а затем увеличивал порядковый номер. Когда порядковый номер достигает 32, он должен вернуться к 0. Посмотрите, сможете ли вы реализовать это, и для дополнительной проблемы попробуйте сделать это, используя только 1 инструкцию (решение в загрузке).
2 Время летит, когда развлекаешься ...

Теперь вы готовы протестировать это на Raspberry Pi. Он должен выдать последовательность из 3 коротких импульсов, 3 длинных импульсов и затем еще 3 коротких импульса (привести к названиям мигания морзянкой в ссср). После задержки узор (привести к литературной формулировке.) должен повториться. Если это не сработает, перейдите на нашу страницу устранения неполадок.

Как только это заработает, поздравляем, вы достигли конца серии руководств OK.

В этой серии статей мы узнали о ассемблере, контроллере GPIO и системном таймере. Мы узнали о функциях и ABI (Двоичный (бинарный) интерфейс приложений), а также о нескольких основных концепциях операционных систем, а также о данных..

Теперь вы готовы перейти к одной из более сложных серий.

    Следующая серия «Экран» научит вас использовать экран с кодом ассемблера.
    Из серии «Ввод» вы узнаете, как пользоваться клавиатурой и мышью.

К настоящему времени у вас уже есть достаточно информации, чтобы операционные системы взаимодействовали с GPIO другими способами. Если у вас есть наборы для роботов, вы можете попробовать написать операционную систему для роботов, управляемую с помощью контактов GPIO!

Обнаружили ошибку? Вы можете помочь этому учебнику на GitHub.

Creative Commons Licence
Baking Pi: Operating Systems Development by Alex Chadwick is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.

Based on contributions at https://github.com/chadderz121/bakingpi-www.

Переводчик этого курса на русский язык Калин Геннадий Геннадьевич, Краснодар.
