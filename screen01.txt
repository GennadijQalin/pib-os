
Занятие 6 Экран01

Добро пожаловать в серию уроков по управлению экраном. В этой серии вы узнаете, как управлять экраном с помощью Raspberry Pi в ассемблерном коде, начиная с простого отображения случайных данных, затем переходя к отображению фиксированного изображения, отображению текста и последующему форматированию чисел в текст. Предполагается, что вы уже выполнили серию ОК, поэтому вещи, описанные в этой серии, здесь не повторяются.

В этом первом уроке на экране изучается базовая теория графики, а затем она применяется для отображения градиентного рисунка на экране или телевизоре.
1 Начинаем.

Ожидается, что вы выполнили серию OK, поэтому функции в файлах 'gpio.s' и 'systemTimer.s' будут вызываться . Если у вас нет этих файлов или вы предпочитаете использовать правильную реализацию, загрузите решение на OK05.s. Отсюда также будет полезен файл main.s, вплоть до mov sp, # 0x8000.  Пожалуйста, удалите все, что находится после этой строки.
2 Компьютерная графика 

Существует несколько систем представления цветов в виде чисел. Здесь мы сосредоточимся на системах RGB, но HSL - еще одна распространенная используемая система.

Вы, я надеюсь, начинаете понимать что, на фундаментальном уровне компьютеры очень глупы. У них есть ограниченное количество инструкций, почти исключительно относящихся к математике, и тем не менее они каким-то образом способны на многое. Сейчас мы хотим понять, как компьютер может выводить изображение на экран. Как бы мы преобразовали эту проблему в двоичную форму? Ответ относительно прост; мы разрабатываем некоторую систему нумерации каждого цвета, а затем сохраняем одно число для каждого пикселя на экране. Пиксель - это маленькая точка на вашем экране. Если вы подойдете очень близко, вы, вероятно, сможете различить отдельные пиксели на экране и сможете увидеть, что все изображение просто состоит из этих пикселей в сочетании.

По мере того, как компьютерный век продвигался, люди хотели все более и более сложной графики, и поэтому была изобретена концепция видеокарты. Графическая карта - это второстепенный процессор на вашем компьютере, который существует только для вывода изображений на экран. . Его задача - преобразовать информацию о значении пикселей в уровни интенсивности света, которые будут передаваться на экран. На современных компьютерах графические карты могут делать гораздо больше, например рисовать трехмерную графику. Однако в этом руководстве мы сосредоточимся только на первом использовании видеокарт; вывод цветов пикселей из памяти на экран.

Одна проблема, которая сразу же поднимается всеми, - это система нумерации цветов. Есть несколько вариантов, каждый из которых дает разное качество. Я остановлюсь на некоторых из них для полноты картины.

Хотя некоторые изображения здесь имеют несколько цветов, они используют технику, называемую пространственным дизерингом. Это позволяет им по-прежнему хорошо отображать изображение с очень небольшим количеством цветов. Многие ранние операционные системы использовали эту технику.
Table 2.1 Some Colour Palettes Name 	Unique Colours 	Description 	Examples
Monochrome 	2 	Use 1 bit to store each pixel, with a 1 being white, and a 0 being black. 	Monochrome image of a bird
Greyscale 	256 	Use 1 byte to store each pixel, with 255 representing white, 0 representing black, and all values in between representing a linear combination of the two. 	Geryscale image of a bird
8 Colour 	8 	Use 3 bits to store each pixel, the first bit representing the presence of a red channel, the second representing a green channel and the third a blue channel. 	8 colour image of a bird
Low Colour 	256 	Use 8 bits to store each pixel, the first 3 bit representing the intensity of the red channel, the next 3 bits representing the intensity of the green channel and the final 2 bits representing the intensity of the blue channel. 	Low colour image of a bird
High Colour 	65,536 	Use 16 bits to store each pixel, the first 5 bit representing the intensity of the red channel, the next 6 bits representing the intensity of the green channel and the final 5 bits representing the intensity of the blue channel. 	High colour image of a bird
True Colour 	16,777,216 	Use 24 bits to store each pixel, the first 8 bits representing the intensity of the red channel, the second 8 representing the green channel and the final 8 bits the blue channel. 	True colour изображение птицы
RGBA32 16,777,216 с 256 уровнями прозрачности Используйте 32 бита для хранения каждого пикселя, первые 8 бит представляют интенсивность красного канала, вторые 8 бит представляют зеленый канал, третьи 8 бит - синий канал, а последние 8 бит - канал прозрачности . Канал прозрачности учитывается только при рисовании одного изображения поверх другого и сохраняется таким образом, что значение 0 указывает цвет изображения за цветом, значение 255 представляет цвет этого изображения, а все значения между ними представляют смесь. 	

В этом уроке мы сначала будем использовать High Color. Как вы можете видеть по изображению, оно дает четкие изображения хорошего качества, но не занимает столько места, сколько True Colour. Тем не менее, для довольно маленького дисплея 800x600 пикселей он все равно займет чуть менее 1 мегабайта пространства. Он также имеет то преимущество, что размер кратен степени двойки, что значительно снижает сложность получения информации по сравнению с True Colour.

Хранение буфера кадра ложится тяжелым бременем на память компьютера. По этой причине ранние компьютеры часто обманывали, например, сохраняя на экранах текст, и просто выводя каждую букву на экран каждый раз, когда он обновляется отдельно.

Raspberry Pi имеет особые и довольно странные отношения со своим графическим процессором. На Raspberry Pi графический процессор фактически запускается первым и отвечает за запуск основного процессора. Это очень необычно. В конечном итоге это не имеет большого значения, но во многих взаимодействиях часто кажется, что процессор второстепенен, а графический процессор является самым важным. Эти двое общаются на Raspberry Pi с помощью того, что называется 'mailbox' - почтовый ящик. Каждый может отправлять почту для другого, которая будет собрана в какой-то момент в будущем, а затем обработана. Мы будем использовать почтовый ящик, чтобы запросить адрес у графического процессора. Адрес будет местом, в которое мы можем записать информацию о цвете пикселей для экрана, называемого буфером кадра, и графическая карта будет регулярно проверять это место и соответствующим образом обновлять пиксели на экране.
3 Программирование почтальона

Передача сообщений - довольно распространенный способ взаимодействия компонентов. Некоторые операционные системы используют виртуальную передачу сообщений, чтобы программы могли обмениваться данными.

The first thПервое, что нам нужно запрограммировать, - это  'postman' почтальон. Это всего два метода: MailboxRead, чтение одного сообщения из канала почтового ящика в r0. и MailboxWrite, записывая значение из верхних 28 бит r0 в канал почтового ящика в r1. Raspberry Pi имеет 7 каналов почтового ящика для связи с графическим процессором, только первый из которых полезен для нас, так как он предназначен для согласования буфера кадра.

В следующей таблице и схемах описывается работа почтового ящика.
Table 3.1 Mailbox Addresses Address 	Size / Bytes 	Name 	Description 	Read / Write
2000B880 	4 	Read 	Receiving mail. 	R
2000B890 	4 	Poll 	Receive without retrieving. 	R
2000B894 	4 	Sender 	Sender information. 	R
2000B898 	4 	Status 	Information. 	R
2000B89C 	4 	Configuration 	Settings. 	RW
2000B8A0 	4 	Write 	Sending mail. 	W

Чтобы отправить сообщение на определенный почтовый ящик:

    Отправитель ждет, пока в верхнем бите поля состояния не будет 0.
    Отправитель пишет в Write, так что 4 младших бита - это почтовый ящик для записи, а старшие 28 бит - это сообщение для записи. 

Чтобы прочитать сообщение:

    Получатель ждет, пока в 30-м бите поля состояния не появится 0.
    Получатель читает из Read.
    Получатель подтверждает, что сообщение предназначено для правильного почтового ящика, и пытается снова, если нет.

Если вы чувствуете себя особенно уверенно, теперь у вас достаточно информации, чтобы написать два необходимых нам метода. Если нет, читайте дальше.

Как всегда, первый метод, который я рекомендую вам реализовать, - это получение адреса региона почтового ящика.

.globl GetMailboxBase
GetMailboxBase:
ldr r0,=0x2000B880
mov pc,lr

Процедура отправки наименее сложна, поэтому сначала реализуем ее. По мере того, как ваши методы становятся все более и более сложными, вам нужно будет начать планировать их заранее. Хороший способ сделать это - написать простой список шагов, которые необходимо сделать, с достаточным количеством деталей, как показано ниже.

    Наш вход будет заключаться в том, что писать (r0) и в какой почтовый ящик писать (r1). Мы должны проверить это, проверив, что это настоящий почтовый ящик, и что младшие 4 бита значения равны 0. Никогда не забывайте проверять вводимые данные.
    Используйте GetMailboxBase, чтобы получить адрес.
    Читать из поля статуса  .
    Убедитесь, что верхний бит равен 0. Если нет, вернитесь к 3.
    Объедините значение для записи и канал.
    Пишите в Write.

Давайте разберемся с каждым из них по порядку.

    .globl MailboxWrite
    MailboxWrite:
    tst r0,#0b1111
    movne pc,lr
    cmp r1,#15
    movhi pc,lr

    tst reg, # val вычисляет и reg, # val и сравнивает результат с 0.

    Это обеспечивает нашу проверку на r0 и r1. tst - это функция, которая сравнивает два числа, вычисляя логическое значение и операцию чисел, а затем сравнивая результат с 0. В этом случае он проверяет, что все младшие 4 бита входа в r0 равны 0.

    channel .req r1
    value .req r2
    mov value,r0
    push {lr}
    bl GetMailboxBase
    mailbox .req r0

    Этот код гарантирует, что мы не будем перезаписывать наше значение или связывать регистр и вызывать GetMailboxBase.

    wait1$:
    status .req r3
    ldr status,[mailbox,#0x18]

    Этот код загружается в текущем состоянии.

    tst status,#0x80000000
    .unreq status
    bne wait1$

    This code checks that the top bit of the status field is 0, and loops back to 3. если это not.

    add value,channel
    .unreq channel

    This code combines the channel and value together.

    str value,[mailbox,#0x20]
    .unreq value
    .unreq mailbox
    pop {pc}

    This code stores the result to the write field.

The code for MailboxRead is quite similar.

    Our input will be what mailbox to read from (r0). We must validate this is by checking it is a real mailbox. Никогда не забывайте проверять вводимые данные.
    Используйте GetMailboxBase, чтобы получить адрес.
    Читать из поля статуса  .
    Check the 30th bit is 0. Если нет, вернитесь к 3.
    Read from the Read field.
    Check the mailbox is the one we want, if not go back to 3.
    Return the result.

Давайте разберемся с каждым из них по порядку.

    .globl MailboxRead
    MailboxRead:
    cmp r0,#15
    movhi pc,lr

    This achieves our validation on r0.

    channel .req r1
    mov channel,r0
    push {lr}
    bl GetMailboxBase
    mailbox .req r0

    Этот код гарантирует, что мы не будем перезаписывать наше значение или связывать регистр и вызывать GetMailboxBase.

    rightmail$:
    wait2$:
    status .req r2
    ldr status,[mailbox,#0x18]

    Этот код загружается в текущем состоянии.

    tst status,#0x40000000
    .unreq status
    bne wait2$

    Этот код проверяет, что 30-й бит поля состояния равен 0, и возвращается к 3. если это not.

    mail .req r2
    ldr mail,[mailbox,#0]

    Этот код считывает следующий элемент из почтового ящика.

    inchan .req r3
    and inchan,mail,#0b1111
    teq inchan,channel
    .unreq inchan
    bne rightmail$
    .unreq mailbox
    .unreq channel

    Этот код проверяет, что канал почты, который мы только что прочитали, совпадает с тем, который нам был предоставлен. Если нет, он возвращается к 3.

    and r0,mail,#0xfffffff0
    .unreq mail
    pop {pc}

    Этот код перемещает ответ (верхние 28 бит сообщения) в r0.

4 Мой самый дорогой графический процессор

Теперь у нас есть возможность отправлять сообщения на видеокарту через нашего нового почтальона. Что мы должны послать? Мне было непросто найти ответ на этот вопрос, поскольку его нет ни в одном онлайн-руководстве, которое я нашел. Тем не менее, глядя на GNU / Linux для Raspberry Pi, мы можем решить, что нам нужно отправить.

Поскольку оперативная память совместно используется графическим процессором и процессором Pi, мы можем просто отправить, где найти наше сообщение. Это называется DMA, многие сложные устройства используют его для ускорения доступа.

Сообщение очень простое. Мы описываем фреймбуфер, который нам нужен, и видеокарта либо соглашается с нашим запросом, и в этом случае она возвращает нам 0 и заполняет небольшую анкету, которую мы составляем, либо она отправляет обратно ненулевое число, и в этом случае мы знаем, что это неудача. К сожалению, я понятия не имею, какие другие числа он может отправить обратно, и что они означают, но только когда он отправляет ноль, он удовледотворен. К счастью, для разумных входных данных всегда окажется, что он отправляет ноль, поэтому нам не нужно слишком беспокоиться.

Для простоты заранее разработаем наш запрос и сохраним его в разделе .data section. В файл с именем framebuffer.s поместите следующий код:

.section .data
.align 4
.globl FrameBufferInfo
FrameBufferInfo:
.int 1024 /* #0 Physical Width */
.int 768 /* #4 Physical Height */
.int 1024 /* #8 Virtual Width */
.int 768 /* #12 Virtual Height */
.int 0 /* #16 GPU - Pitch */
.int 16 /* #20 Bit Depth */
.int 0 /* #24 X */
.int 0 /* #28 Y */
.int 0 /* #32 GPU - Pointer */
.int 0 /* #36 GPU - Size */

Это формат наших сообщений графическому процессору. Первые два слова описывают физическую ширину и высоту. Вторая пара - это виртуальная ширина и высота. Ширина и высота фреймбуфера - это виртуальная ширина и высота, а графический процессор масштабирует фреймбуфер по мере необходимости, чтобы соответствовать физическому экрану. Следующее слово - одно из тех, которые будет заполнять графический процессор, если он выполнит наш запрос. Это будет количество байтов в каждой строке буфера кадра, в данном случае 2 × 1024 = 2048.. Следующее слово - сколько бит выделить каждому пикселю. Использование значения 16 означает, что графический процессор использует режим High Color, описанный выше. Значение 24 будет использовать True Color, а 32 будет использовать RGBA32. Следующие два слова - это смещения по x и y, которые означают количество пикселей, которые нужно пропустить в верхнем левом углу экрана при копировании фреймбуфера на экран. Наконец, последние два слова заполняются графическим процессором, первое из которых является фактическим указателем на буфер кадра, а второе - размером буфера кадра в байтах.

При работе с устройствами, использующими DMA, ограничения выравнивания становятся очень важными. Графический процессор ожидает, что сообщение будет выровнено по 16 байтам.

Я был очень осторожен, включив сюда .align 4 here. Как обсуждалось ранее, это гарантирует, что младшие 4 бита адреса следующей строки равны 0. Таким образом, мы точно знаем, что FrameBufferInfo будет размещен по адресу, который мы можем отправить графическому процессору, поскольку наш почтовый ящик отправляет только значения с младшими 4 битами, все 0.

Итак, теперь, когда у нас есть сообщение, мы можем написать код для его отправки. Общение будет происходить следующим образом:

    Запишите адрес FrameBufferInfo + 0x40000000 в почтовый ящик mailbox 1.
    Прочтите результат из почтового ящика mailbox 1. Если он не равен нулю, то мы не запросили правильный буфер кадра.
    Скопируйте наши изображения на указатель, и они появятся на экране!

Я сказал то, что не упоминал ранее на шаге 1. Мы должны добавить 0x40000000 к адресу FrameBufferInfo перед его отправкой. На самом деле это особый сигнал графическому процессору GPU о том, как он должен писать в структуру. Если мы просто отправим адрес, графический процессор напишет свой ответ, но не позаботится о том, чтобы мы могли его увидеть, очистив свой кеш. Кэш - это часть памяти, в которой процессор сохраняет значения, с которыми он работает, перед отправкой их в ОЗУ. Добавляя 0x40000000, мы говорим графическому процессору не использовать свой кеш для этих записей, что гарантирует, что мы сможем увидеть изменение.

Поскольку там происходит довольно много всего, было бы лучше реализовать это как функцию, а не просто помещать код в main.s. Мы напишем функцию InitialiseFrameBuffer, которая выполняет все эти согласования и возвращает указатель на данные вышеупомянутого буфера кадра, если в нем есть указатель. Для простоты мы также должны сделать так, чтобы ширина, высота и битовая глубина буфера кадра были входными данными для этого метода, чтобы его можно было легко изменить в main.s, не вдаваясь в детали согласования.

Еще раз подробно запишем, какие шаги нам придется предпринять. Если вы чувствуете себя уверенно, попробуйте сразу написать функцию.

    Подтвердите наши входные данные.
    Записать входные данные в фреймбуфер.
    Отправить на почтовый ящик адрес фрейм-буфера + 0x40000000.
    Получите ответ от почтового ящика.
    Если ответ не равен 0, метод не удался. Мы должны вернуть 0, чтобы указать на сбой.
    Вернуть указатель на информацию о буфере кадра.

Теперь мы используем гораздо более масштабные методы, чем раньше. Ниже приведена одна из реализаций вышеизложенного. 

    .section .text
    .globl InitialiseFrameBuffer
    InitialiseFrameBuffer:
    width .req r0
    height .req r1
    bitDepth .req r2
    cmp width,#4096
    cmpls height,#4096
    cmpls bitDepth,#32
    result .req r0
    movhi result,#0
    movhi pc,lr

    This code checks that the width and height are less than or equal to 4096, and that the bit depth is less than or equal to 32. This is once again using a trick with conditional execution. Convince yourself that this works.

    fbInfoAddr .req r3
    push {lr}
    ldr fbInfoAddr,=FrameBufferInfo
    str width,[fbInfoAddr,#0]
    str height,[fbInfoAddr,#4]
    str width,[fbInfoAddr,#8]
    str height,[fbInfoAddr,#12]
    str bitDepth,[fbInfoAddr,#20]
    .unreq width
    .unreq height
    .unreq bitDepth

    Этот код просто записывает в наш фреймбуфер, структуру определенную выше. Я также пользуюсь возможностью поместить регистр ссылок (link register) в стек.

     mov r0,fbInfoAddr
    add r0,#0x40000000
    mov r1,#1
    bl MailboxWrite

    Входные данные для метода MailboxWrite - это значение для записи в r0 и канал для записи в r1.

    mov r0,#1
    bl MailboxRead

    Входные данные для метода MailboxRead - это канал для записи в r0, а выход - это прочитанное значение.

    teq result,#0
    movne result,#0
    popne {pc}

    Этот код проверяет, равен ли результат метода MailboxRead 0, и возвращает 0, если нет.

    mov result,fbInfoAddr
    pop {pc}
    .unreq result
    .unreq fbInfoAddr

    Этот код завершается и возвращает фреймбуфер в адрес frame buffer info address.

5 Пиксель В строке Внутри кадра

Итак, мы создали наши методы для связи с графическим процессором. Теперь он должен иметь возможность давать нам указатель на буфер кадра, в который мы можем рисовать графику. Давай сейчас что-нибудь нарисуем.

В этом первом примере мы просто рисуем на экране последовательные цвета. Это не будет выглядеть красиво, но, по крайней мере, будет работать. Мы сделаем это, установив каждому пикселю в буфере кадра последовательный номер. и постоянно будем это делать. 

Скопируйте следующий код в main.s после mov sp, # 0x8000

mov r0,#1024
mov r1,#768
mov r2,#16
bl InitialiseFrameBuffer

Этот код просто использует наш метод InitialiseFrameBuffer для создания буфера кадра с шириной 1024, высотой 768 и битовой глубиной 16. Вы можете попробовать здесь разные значения, если хотите, при условии, что вы едины во всем коде. Поскольку возможно, что этот метод может вернуть 0, если графический процессор не предоставил нам буфер кадра, нам лучше проверить это и включить светодиод OK, если это произойдет.

teq r0,#0
bne noError$

mov r0,#16
mov r1,#1
bl SetGpioFunction
mov r0,#16
mov r1,#0
bl SetGpio

error$:
b error$

noError$:
fbInfoAddr .req r4
mov fbInfoAddr,r0

Теперь, когда у нас есть информационный адрес буфера кадра, нам нужно получить от него указатель буфера кадра и начать рисование на экране. Мы будем делать это с помощью двух петель (циклов?), одна идет вниз по строкам, а другая - по столбцам. На Raspberry Pi, действительно, в большинстве приложений изображения хранятся слева направо, затем сверху вниз, поэтому мы должны выполнять циклы в указанном мной порядке.

render$:

fbAddr .req r3
ldr fbAddr,[fbInfoAddr,#32]

colour .req r0
y .req r1
mov y,#768
drawRow$:

x .req r2
mov x,#1024
drawPixel$:

strh colour,[fbAddr]
add fbAddr,#2
sub x,#1
teq x,#0
bne drawPixel$


sub y,#1
add colour,#1
teq y,#0
bne drawRow$

b render$


.unreq fbAddr
.unreq fbInfoAddr

strh reg, [dest] сохраняет младший номер полуслова в reg по адресу, указанному в dest.

Это довольно большой фрагмент кода, в котором есть цикл внутри цикла внутри цикла. Чтобы помочь вам разобраться в цикле, я сделал отступ в коде, который зациклен, в зависимости от того, в каком цикле он находится. Это довольно часто встречается в большинстве языков программирования высокого уровня, и ассемблер просто игнорирует вкладки. Мы видим здесь, что я загружаю адрес буфера кадра из информационной структуры буфера кадра, а затем перебираю каждую строку, затем каждый пиксель в строке. На каждом пикселе я использую команду strh (сохранить полуслова) для сохранения текущего цвета, а затем увеличиваю адрес, на который мы пишем. После рисования каждой строки мы увеличиваем цвет, который мы рисуем. После рисования полного экрана, мы возвращаемся к началу
6 Увидеть свет

Теперь вы готовы протестировать этот код на Raspberry Pi. Вы должны увидеть меняющийся узор градиента. Будьте осторожны: пока в почтовый ящик не будет отправлено первое сообщение, Raspberry Pi отображает неподвижный градиентный узор между четырьмя углами. Если это не сработает, перейдите на нашу страницу устранения неполадок.

Если это сработало, поздравляем! Теперь вы можете управлять экраном! Не стесняйтесь изменять этот код, чтобы рисовать любой узор, который вам нравится. Вы можете сделать несколько очень хороших шаблонов градиента и можете вычислить значение каждого пикселя напрямую, поскольку y содержит координату y для пикселя, а x содержит координату x. В следующем уроке, Урок 7: Экран 02, мы рассмотрим одну из наиболее распространенных задач рисования - линии.

Обнаружили ошибку? Вы можете помочь этому учебнику на GitHub.

Creative Commons Licence
Baking Pi: Operating Systems Development by Alex Chadwick is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.

Based on contributions at https://github.com/chadderz121/bakingpi-www.
 
