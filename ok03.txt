
Занятие 3 OK03

Занятие OK03 основано на OK03T обучает, как использовать функции в сборке, чтобы сделать более многоразовый и читаемый код. Предполагается, что у вас есть код для урока 2: Операционная система OK02 в качестве основы.
1 Повторно используемый код

До сих пор мы писали код для нашей операционной системы, набирая  его так чтобы он выполнялся по порядку. Это нормально для таких крошечных программ, но если бы мы написали всю систему таким образом, код был бы совершенно нечитабельным. Вместо этого мы будем использовать функции.

Объяснение функций
Функционируют как черные ящики.

Функции называются «черными ящиками». Мы вводим вводные данные и выводим результаты, но нам не нужно знать, как функции работают.

В коде более высокого уровня, таком как C или C ++, функции являются частью самого языка. В ассемблерном коде функции - это просто идеи, которые у нас есть.

В идеале мы хотим иметь возможность установить наши регистры на некоторые входные значения, перейти к адресу и ожидать, что в какой-то момент код вернется к нашему коду, установив регистры на выходные значения. Вот что такое функция в ассемблерном коде. Трудность в том, что за систему мы используем для настройки регистров.. Если мы просто используем любую систему, которая нам нравится, каждый программист мог бы использовать другую систему, и было бы трудно понять работу других программистов. Более того компиляторы не смогут так легко работать с кодом сборки, поскольку они не будут знать, как использовать функции. Чтобы не было путаницы, для каждого языка ассемблера был разработан стандарт под названием Application Binary Interface (ABI), который является соглашением о том, как должны выполняться функции. Если все создли функции одинаково, тогда каждый сможет использовать функции друг друга. Я научу этому стандарту здесь, и с этого момента я буду писать код всех своих функций в соответствии со стандартом.

Стандарт говорит, что r0, r1, r2 и r3 будут использоваться в качестве входных данных для функции по порядку. Если функции не нужны входные данные, не имеет значения, какое значение она принимает. Если ей нужен только один, он всегда идет в r0, если ему нужны два, первый идет в r0, а второй идет в r1, и так далее. Выход всегда будет находиться в r0. Если функция не имеет выходных данных, то не имеет значения, котороге принимает r0.

Кроме того, он (стандарт) также требует, чтобы после запуска функции r4 - r12 имели те же значения, что и при запуске функции. Это означает, что когда вы вызвали функции вы можете быть уверены, что r4 - r12 не изменит значения, но вы не можете быть так уверены в r0 - r3.

Когда функция завершается, она должна вернуться к коду, который ее запустил. Это означает, что он должен знать адрес кода, который его запустил. Чтобы облегчить это, существует специальный регистр, называемый LR (link register), который всегда содержит адрес инструкции после того, который вызвал эту функцию.
Table 1.1 ARM ABI регистр использует Register 	Brief 	Preserved 	Rules
r0 	Аргумент  и результат 	No 	r0 and r1 используются для передачи первых двух аргументов функциям и возврата результатов функций. Если функция не использует их для возвращаемого значения, они могут принимать любое значение после функции.
r1 	Аргумент и результат 	No
r2 	Аргумент 	No 	r2 и r3 используются для передачи вторых двух аргументов функциям. Значения после вызова функции могут быть любыми.
r3 	Аргумент 	No
r4 	Общее назначение 	Yes 	r4 – r12 используются для рабочих значений, и их значение после вызова функции должно быть таким же, как и раньше.
r5 	Общее назначение 	Yes
r6 	Общее назначение 	Yes
r7 	Общее назначение 	Yes
r8 	Общее назначение 	Yes
r9 	Общее назначение 	Yes
r10 	Общее назначение 	Yes
r11 	Общее назначение 	Yes
r12 	Общее назначение 	Yes
lr 	Возврат адресса 	No 	lr  это адрес, к которому следует вернуться после завершения функции, но он должен содержать тот же адрес после завершения функции.
sp 	Указатель стека 	Yes 	sp это указатель стека, описанный ниже. Его значение должно быть таким же после завершения функции.

Часто функциям требуется использовать больше регистров, чем просто от r0 до r3. Но, поскольку от r4 до r12 должны оставаться неизменными после запуска метода, они должны быть где-то сохранены. Мы сохраняем их на чем-то, называемом стеком.

Объяснение, что такое стек.
Стек - это метафора, которую мы используем в вычислениях для метода хранения значений. Как и в стопке тарелок, вы можете удалять элементы только из верхней части стопки и добавлять элементы только из верхней части стопки.

Стек - отличная идея для хранения регистров при выполнении функций. Например, если у меня есть функция, которая должна использовать регистры r4 и r5, она может поместить текущие значения этих регистров в стек. В конце метода он может снова снять их. Что наиболее умно, так это то, что если бы моя функция должна была запустить другую функцию для завершения и этой функции нужно было сохранить некоторые регистры, она могла бы поместить их в верхнюю часть стека во время работы, а затем снова снять их в конце. Это не повлияет на значения r4 и r5, которые мой метод должен был сохранить, поскольку они будут добавлены в верхнюю часть стека, а затем снова удалены.

Терминология, которую мы использовали для обозначения значений, помещаемых в стек определенным методом, такова, что этот метод называется «стековый кадр». Не каждому методу нужен стековый фрейм, некоторым не нужно хранить значения.

Поскольку стек настолько полезен, он был напрямую реализован в наборе инструкций ARMv6. В специальном регистре sp (указатель стека) хранится адрес стека. Когда элементы добавляются в стек, регистр sp обновляется, так что он всегда содержит адрес первого элемента в стеке. push {r4, r5} поместит значения в r4 и r5 на вершину стека, а pop {r4, r5} вернет их обратно (в правильном порядке).
2 Наша первая функция

Теперь, когда у нас есть некоторое представление о том, как работают функции, давайте попробуем создать одну из них. В качестве основного первого примера мы собираемся создать функцию, которая не принимает входных данных и выдает на выходе адрес GPIO. В прошлом уроке мы просто записали это значение, но было бы лучше как функция, поскольку это то, что нам, возможно, придется часто делать в реальной операционной системе, и мы не всегда можем запомнить адрес.

Скопируйте следующий код в новый файл с именем gpio.s. Просто создайте новый файл в каталоге 'source' с 'main.s'. Мы собираемся поместить все функции, связанные с контроллером GPIO, в один файл, чтобы их было легче найти.

.globl GetGpioAddress
GetGpioAddress:
ldr r0,=0x20200000
mov pc,lr

.globl lbl делает метку lbl доступной из других файлов.

mov reg1, reg2 копирует значение из reg2 в reg1.

Это очень простая полная функция. Команда .globl GetGpioAddress - это сообщение ассемблеру, чтобы сделать метку GetGpioAddress доступной для всех файлов. Это означает, что в нашем файле main.s мы можем перейти к метке GetGpioAddress, даже если она не определена в этом файле.

Вы должны узнать команду ldr r0, = 0x20200000, которая хранит адрес контроллера GPIO в r0. Поскольку это функция, мы должны выдавать результат в r0, поэтому мы не можем использовать любой регистр так же свободно, как когда-то.

mov pc, lr копирует значение из lr на pc. Как упоминалось ранее, lr всегда содержит адрес кода, к которому мы должны вернуться после завершения метода. pc это специальный регистр, который всегда содержит адрес следующей инструкции, которая будет запущена. Обычная команда ветвления просто изменяет значение этого регистра. Копируя значение в lr на pc, мы просто меняем следующую запускаемую строку на ту, которую нам сказали вернуться к.

AВозникает резонный вопрос: как на самом деле запустить этот код? Специальный тип ветки bl делает то, что нам нужно. Он переходит к метке, как обычная ветвь, но перед этим обновляет lr, чтобы содержать адрес строки после ветки. Это означает, что когда функция завершится, строка, к которой она вернется, будет строкой после команды bl. Это делает выполняемую функцию похожей на любую другую команду, она просто запускается, делает все, что ей нужно, а затем переходит к следующей строке. Это действительно полезный способ думать о функциях. Мы относимся к ним как к «черным ящикам», поскольку, когда мы их используем, нам не нужно думать о том, как они работают, нам просто нужно знать, какие входные данные им нужны и какие результаты они дают.

Пока не беспокойтесь об использовании функции, мы будем использовать ее в следующем разделе.
3 Большая функция

Теперь мы собираемся реализовать более крупную функцию. Нашей первой задачей было включение вывода на вывод 16 GPIO. Было бы неплохо, если бы это была функция. Мы могли бы просто указать вывод и функцию в качестве входа, и функция установила бы функцию этого вывода на это значение. Таким образом, мы могли использовать код для управления любым выводом GPIO, а не только светодиодом.

Скопируйте следующие команды под функцией GetGpioAddress в gpio.s.

.globl SetGpioFunction
SetGpioFunction:
cmp r0,#53
cmpls r1,#7
movhi pc,lr

Суффикс ls вызывает выполнение команды только в том случае, если последнее сравнение определило, что первое число меньше или совпадает со вторым. Неподписанный.

Суффикс hi вызывает выполнение команды только в том случае, если последнее сравнение определило, что первое число было больше второго. Неподписанный.

Одна из первых вещей, о которой мы всегда должны думать при написании функций, - это наши входные данные. Что нам делать, если они ошибаются? В этой функции у нас есть один вход, который представляет собой номер контакта GPIO, поэтому он должен быть числом от 0 до 53, так как контактов 54. Каждый вывод имеет 8 функций, пронумерованных от 0 до 7, поэтому код функции также должен быть. Мы могли бы просто предположить, что входные данные будут правильными, но это очень опасно при работе с оборудованием, поскольку неправильные значения могут вызвать очень серьезные побочные эффекты. Поэтому в этом случае мы хотим убедиться, что входные данные находятся в правильных диапазонах.

Для этого нужно проверить, что r0 <= 53 и r1 <= 7. Прежде всего, мы можем использовать сравнение, которое мы видели ранее, чтобы сравнить значение r0 с 53. Следующая инструкция cmpls - это обычная инструкция сравнения, которая будет выполняться, только если r0 меньше или равно 53. Если это было так, он сравнивает r1 с 7, в противном случае результат сравнения такой же, как и раньше. Наконец, мы возвращаемся к коду, который запускал функцию, если результатом последнего сравнения было то, что регистр был выше числа.

Эффект от этого именно то, что мы хотим. Если r0 было больше 53, то команда cmpls не запускается, но movhi выполняет. Если r0 <= 53, то команда cmpls выполняется, и поэтому r1 сравнивается с 7, а затем, если оно больше 7, запускается movhi и функция завершается, иначе movhi не запускается, и мы знаем, что мы убедились, что r0 <= 53 и r1 <= 7.

Существует небольшая разница между суффиксами ls (lower or same более низкий или такой же) и le (ess or equal меньший или равный), а также между суффиксами hi (higher более высокий) и gt (greater более высокий), но я расскажу об этом позже.

Скопируйте эти команды под указанным выше.

push {lr}
mov r2,r0
bl GetGpioAddress

push {reg1, reg2, ...} копирует регистры из списка reg1, reg2, ... в верхнюю часть стека. Можно проталкивать только регистры общего назначения и lr.

bl lbl устанавливает lr в адрес следующей инструкции, а затем переходит к метке lbl.

Следующие три команды предназначены для вызова нашего первого метода. Команда push {lr} копирует значение в lr в верхнюю часть стека, чтобы мы могли получить его позже. Мы должны это сделать, потому что, когда мы вызываем GetGpioAddress, нам нужно будет использовать lr для хранения адреса, на который нужно вернуться в нашей функции.

Если бы мы ничего не знали о функции GetGpioAddress, нам пришлось бы предположить, что она изменяет r0, r1, r2 и r3, и нам пришлось бы переместить наши значения в r4 и r5, чтобы они оставались неизменными после завершения. К счастью, мы знаем о GetGpioAddress, и мы знаем, что он меняет только r0 на адрес, это не влияет на r1, r2 или r3. Таким образом, нам нужно только переместить номер вывода GPIO из r0, чтобы он не был перезаписан, но мы знаем, что можем безопасно переместить его в r2, поскольку GetGpioAddress не меняет r2.

Наконец, мы используем инструкцию bl для запуска GetGpioAddress. Обычно мы используем термин «вызов» для запуска функции, и теперь я буду сейчас использовать его. Как обсуждалось ранее, bl вызывает функцию, обновляя lr до адреса следующей инструкции, а затем переходя к функции.

Когда функция завершается, мы говорим, что она «вернулась (returned)». Когда вызов GetGpioAddress возвращается, мы теперь знаем, что r0 содержит адрес GPIO, r1 содержит код функции, а r2 содержит номер контакта GPIO. Я упоминал ранее, что функции GPIO хранятся в блоках по 10, поэтому сначала нам нужно определить, в каком блоке из десяти находится наш номер контакта. Это похоже на работу, для которой мы бы использовали деление, но деление действительно очень медленное, поэтому для таких маленьких чисел лучше выполнять повторное вычитание.

Скопируйте следующий код под приведенным выше.

functionLoop$:

cmp r2,#9
subhi r2,#10
addhi r0,#4
bhi functionLoop$

add reg, # val добавляет число val к содержимому регистра reg.

Этот простой код цикла сравнивает номер вывода с 9. Если он больше 9, он вычитает 10 из номера контакта и добавляет 4 к адресу контроллера GPIO, а затем снова запускает проверку.

В результате r2 теперь будет содержать число от 0 до 9, которое представляет собой остаток от деления номера вывода на 10. r0 теперь будет содержать адрес в контроллере GPIO настроек функции этого вывода. Это будет то же самое, что и адрес контроллера GPIO + 4 × (номер контакта GPIO ÷ 10).

Наконец, скопируйте следующий код под приведенным выше.

add r2, r2,lsl #1
lsl r1,r2
str r1,[r0]
pop {pc}

Аргумент shift reg, lsl #val сдвигает двоичное представление числа в reg, оставленное val, прежде чем использовать его в предыдущей операции.

lsl reg, amt сдвигает двоичное представление числа в reg влево на число в amt.

str reg, [dst] то же самое, что и str reg,[dst,#0].

pop {reg1, reg2, ...} копирует значения из вершины стека в список регистров reg1, reg2,.... Можно вытолкнуть только регистры общего назначения и pc.

Этот код завершает метод. Первая строка на самом деле является замаскированным умножением на 3. Умножение - это большая и медленная инструкция в ассемблерном коде, так как схеме может потребоваться много времени, чтобы придумать ответ. Иногда гораздо быстрее использовать некоторые инструкции, которые могут быстрее получить ответ. В этом случае я знаю, что r2 × 3 совпадает с r2 × 2 + r2. Очень легко умножить регистр на 2, поскольку это удобно то же самое, что сдвигать двоичное представление числа, оставленного на одну позицию.

Одной из очень полезных функций языка ассемблера ARMv6 является возможность сдвигать аргумент перед его использованием. В этом случае я добавляю r2 к результату сдвига двоичного представления r2 влево на одну позицию. В ассемблерном коде вы часто используете подобные приемы для более легкого вычисления ответов, но если вам это неудобно, вы также можете написать что-то вроде mov r3, r2; добавить r2, r3; добавить r2, r3.

Теперь сдвинем значение функции влево на количество разрядов, равное r2. Большинство инструкций, таких как add и sub, имеют вариант, который использует регистр, а не число для суммы. Мы выполняем этот сдвиг, потому что хотим установить биты, соответствующие нашему номеру вывода, а на каждый вывод приходится три бита.

Затем мы сохраняем вычисленное значение функции по адресу в контроллере GPIO. Мы уже определили адрес в цикле, поэтому нам не нужно сохранять его по смещению, как мы это делали в OK01 и OK02.

Наконец, мы можем вернуться из этого вызова метода. Поскольку мы поместили lr в стек, если мы вытолкнем pc, он скопирует значение, которое было в lr в то время, когда мы помещали его в pc. Это будет то же самое, что использовать mov pc, lr и поэтому вызов функции вернется, когда эта строка будет запущена.

Очень увлеченные могут заметить, что эта функция на самом деле работает некорректно. Хотя он устанавливает функцию вывода GPIO на запрошенное значение, он заставляет все выводы в одном блоке из 10 функций возвращаться к 0! Это, вероятно, будет довольно неприятно в системе, в которой интенсивно используются контакты GPIO. Я оставляю заинтересованным лицам задачу исправить эту функцию, чтобы она не перезаписывала значения других контактов, гарантируя, что все биты, кроме 3, которые должны быть установлены, остаются такими же. Решение этой проблемы можно найти на странице загрузок этого урока. Функции, которые могут оказаться полезными, - это функции, которые вычисляют логическое значение и функцию двух регистров: mvns, который вычисляет логическое значение not, и orr, которое вычисляет логическое значение или.
4 Другая функция

Итак, теперь у нас есть функция, которая заботится о настройке функции вывода GPIO. Теперь нам нужно создать функцию для включения или выключения вывода GPIO. Вместо того, чтобы иметь одну функцию для выключения и одну функцию для включения, было бы удобно иметь одну функцию.

Мы создадим функцию с именем SetGpio, которая принимает номер вывода GPIO в качестве первого входа в r0 и значение в качестве второго в r1. Если значение равно 0, мы выключим контакт, а если он не равен нулю, мы включим его.

Скопируйте и вставьте следующий код в конец файла gpio.s.

.globl SetGpio
SetGpio:
pinNum .req r0
pinVal .req r1

Псевдоним .req reg устанавливает псевдоним для обозначения регистра reg.

Еще раз нам нужны команда .globl и метка, чтобы сделать функцию доступной из других файлов. На этот раз мы будем использовать псевдонимы регистров. Псевдонимы регистров позволяют нам использовать имя, отличное от r0 или r1, для регистров. Возможно, сейчас это не так важно, но позже окажется бесценным при написании больших методов, и с этого момента вам следует попробовать использовать псевдонимы. pinNum .req r0 означает, что pinNum теперь означает r0 при использовании в инструкциях.

Скопируйте и вставьте следующий код после указанного выше.

cmp pinNum,#53
movhi pc,lr
push {lr}
mov r2,pinNum
.unreq pinNum
pinNum .req r2
bl GetGpioAddress
gpioAddr .req r0

.unreq alias (псевдоним) удаляет псевдоним псевдонима. .

Как и в случае с SetGpioFunction, первое, что мы должны сделать, это проверить, действительно ли нам предоставлен действительный номер контакта. Мы делаем это точно так же, сравнивая pinNum (r0) с 53 и немедленно возвращаясь, если оно выше. Мы снова хотим вызвать GetGpioAddress, поэтому нам нужно сохранить lr, поместив его в стек, и переместить pinNum в r2. Затем мы используем оператор .unreq, чтобы удалить наш псевдоним из r0. Поскольку номер вывода теперь хранится в r2, мы хотим, чтобы наш псевдоним отражал это, поэтому мы удаляем псевдоним из r0 и переделываем его на r2. Вы всегда должны .unreq каждый псевдоним, как только он будет выполнен, чтобы вы не могли совершить ошибку, используя его дальше по коду, когда он больше не существует.

Затем мы вызываем GetGpioAddress и создаем псевдоним для r0, чтобы отразить это.

Скопируйте и вставьте следующий код после указанного выше.

pinBank .req r3
lsr pinBank,pinNum,#5
lsl pinBank,#2
add gpioAddr,pinBank
.unreq pinBank

lsr dst, src, # val сдвигает двоичное представление числа в src вправо на val, но сохраняет результат в dst.

Контроллер GPIO имеет два набора по 4 байта каждый для включения и выключения контактов. Первый набор в каждом случае контролирует первые 32 контакта, а второй набор контролирует оставшиеся 22. Чтобы определить, в каком наборе он находится, нам нужно номер вывода разделить на 32. К счастью, это очень просто, это то же самое, что сдвинуть двоичное представление номера вывода вправо на 5 разрядов. Следовательно, в этом случае я назвал r3 как pinBank, а затем вычислил pinNum ÷ 32. Поскольку это набор из 4 байтов, тогда нам нужно умножить результат на 4. Это то же самое, что сдвиг двоичного представления влево на 2 позиции, что является следующей командой. Вы можете спросить, не могли бы мы просто сдвинуть его вправо на 3 места, когда мы пошли направо, затем налево. Однако это не сработает, так как часть ответа могла быть округлена, когда мы использовали ÷ 32, а может и не быть, если мы просто ÷ 8.

В результате gpioAddr теперь содержит 2020000016, если номер контакта 0-31, и 2020000416, если номер контакта 32-53. Это означает, что если мы добавим 2810, мы получим адрес для включения контакта, а если мы добавим 4010, мы получим адрес для отключения контакта. Так как мы закончили с pinBank, я сразу же использую .unreq.

Скопируйте и вставьте следующий код после указанного выше.

and pinNum,#31
setBit .req r3
mov setBit,#1
lsl setBit,pinNum
.unreq pinNum

и reg, # val вычисляет логическое значение и функцию числа в reg с val.

Следующая часть функции предназначена для генерации числа с правильным набором битов. Чтобы контроллер GPIO мог включать или выключать вывод, мы даем ему номер с битом, установленным вместо остатка номера этого вывода, деленного на 32. Например, чтобы установить вывод 16, нам нужно число с 16-м битом равным 1. Чтобы установить вывод 45, нам понадобится число с 13-м битом 1 как 45 ÷ 32 = 1 остаток 13.

Команда и вычисляет необходимый остаток. Как это происходит? Результатом операции и является число с единицами во всех двоичных цифрах, которые имели единицы на обоих входах и нули в других местах. Это фундаментальная бинарная операция, и она выполняется очень быстро. Мы дали ему входы pinNum и 3110 = 111112. Это означает, что ответ может иметь только 1 бит в последних 5 разрядах, и поэтому определенно находится между 0 и 31. В частности, у него есть только единицы, где в последних 5 местах pinNum было 1. Это то же самое, что и остаток от деления на 32. Неслучайно 31 = 32 - 1.
пример двоичного деления

Остальная часть этого кода просто использует это значение для смещения числа 1 влево. Это приводит к созданию нужного нам двоичного числа.

Скопируйте и вставьте следующий код после указанного выше.

teq pinVal,#0
.unreq pinVal
streq setBit,[gpioAddr,#40]
strne setBit,[gpioAddr,#28]
.unreq setBit
.unreq gpioAddr
pop {pc}

teq reg, # val проверяет, равно ли число в reg значению val.

Этот код завершает метод. Как было сказано ранее, мы отключаем контакт, если pinVal равен нулю, и включаем в противном случае. teq (проверка равенства) - еще одна операция сравнения, которая может использоваться только для проверки равенства. Он похож на cmp, но не определяет, какое число больше. Если все, что вы хотите сделать, это проверить, совпадают ли числа, вы можете использовать teq.

Если pinVal равен нулю, мы сохраняем setBit на расстоянии 40 от адреса GPIO, что, как мы уже знаем, отключает контакт. В противном случае мы сохраняем его на 28, что включает контакт. Наконец, мы возвращаемся, вытаскивая pc, который устанавливает для него значение, которое мы сохранили, когда нажали регистр ссылки..
5 Новое начало

Наконец, после всей этой работы у нас есть функции GPIO. Теперь нам нужно изменить main.s, чтобы использовать их. Поскольку файл main.s сейчас становится намного больше и сложнее, поэтому лучше разделить его на две части. '.Init', который мы использовали до сих пор, лучше всего делать как можно меньше. Мы можем изменить код, чтобы это легко отразить.

Вставьте следующее сразу после _start: в main.s:

b main

.section .text
main:
mov sp,#0x8000

Ключевое изменение, которое мы здесь сделали, - это введение раздела .text. Я разработал сценарии makefile и компоновщика таким образом, что код в разделе .text (который является разделом по умолчанию) помещается после раздела .init, который находится по адресу 800016. Это адрес загрузки по умолчанию, он дает нам немного места для хранения стека. Поскольку стек существует в памяти, он должен иметь адрес. Стек увеличивается вниз по памяти, так что каждое новое значение находится на более низком адресе, таким образом, делая «верх» стека, наименьшим адресом.

Раздел «ATAGs» на схеме - это место, где хранится информация о Raspberry Pi, например, сколько у него памяти и каково его разрешение экрана по умолчанию.
Схема расположения операционной системы

Замените весь код, устанавливающий функцию вывода GPIO, следующим:

pinNum .req r0
pinFunc .req r1
mov pinNum,#16
mov pinFunc,#1
bl SetGpioFunction
.unreq pinNum
.unreq pinFunc

Этот код вызывает SetGpioFunction с номером контакта 16 и контактом функции 1. Это приводит к разрешению вывода на светодиод OK.

Замените любой код, который включает светодиод OK, следующим:

pinNum .req r0
pinVal .req r1
mov pinNum,#16
mov pinVal,#0
bl SetGpio
.unreq pinNum
.unreq pinVal

Этот код использует SetGpio для отключения вывода 16 GPIO, таким образом, загорается светодиод OK. Если бы мы вместо этого использовали mov pinVal, # 1, он бы выключил светодиод. Замените свой старый код, чтобы выключить светодиод.
6 Вперед

Надеюсь, теперь вы сможете протестировать то, что сделали на Raspberry Pi. На этот раз мы написали большой объем кода, поэтому многое может пойти не так. Если это так, перейдите на страницу устранения неполадок.

Когда все заработает, мои поздравления. Хотя наша операционная система не делает ничего больше, чем она делала в Уроке 2: OK02, мы многое узнали о функциях и форматировании, и теперь мы можем кодировать новые функции гораздо быстрее. Теперь было бы очень просто создать операционную систему, которая изменяет любой регистр GPIO, который можно было бы использовать для управления оборудованием!

В Уроке 4: OK04 мы рассмотрим нашу функцию ожидания, которая в настоящее время неточна, чтобы мы могли лучше контролировать наш светодиод и, в конечном итоге, все контакты GPIO.

Обнаружили ошибку? Вы можете помочь этому учебнику на GitHub.

Creative Commons Licence
Baking Pi: Operating Systems Development by Alex Chadwick is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.

Based on contributions at https://github.com/chadderz121/bakingpi-www.
 
 Переводчик этого курса на русский язык Калин Геннадий Геннадьевич, Краснодар.

